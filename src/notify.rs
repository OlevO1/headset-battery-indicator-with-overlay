use crate::headset_control::BatteryState;

use anyhow::{Context, Result};
use win32_notif::{
    NotificationBuilder, ToastsNotifier,
    notification::visual::{Text, text::HintStyle},
};
#[cfg(windows)]
use windows::{Win32::UI::Shell::SetCurrentProcessExplicitAppUserModelID, core::HSTRING};

pub struct Notifier {
    toast_notifier: ToastsNotifier,
    last_notification_state: Option<(isize, BatteryState)>,
}

impl Notifier {
    pub fn new() -> anyhow::Result<Self> {
        let app_id = register_notifications_id().context("registering notifications id")?;
        let toast_notifier = ToastsNotifier::new(app_id)?;
        Ok(Self {
            toast_notifier,
            last_notification_state: None,
        })
    }

    pub fn update(
        &mut self,
        current_level: isize,
        current_status: BatteryState,
        product_name: &str,
    ) {
        if let Some((last_level, last_status)) = self.last_notification_state {
            let mut msg = None;

            let battery_discharging = current_status == BatteryState::BatteryAvailable;
            let battery_charging = current_status == BatteryState::BatteryCharging;

            // Low battery (10%)
            if current_level <= 10 && last_level > 10 && battery_discharging {
                msg = Some(format!("Battery low ({}%)", current_level));
            }
            // Critical battery (3%)
            else if current_level <= 3 && last_level > 3 && battery_discharging {
                msg = Some(format!("Battery critical ({}%)", current_level));
            }
            // Charging started
            else if battery_charging && last_status != BatteryState::BatteryCharging {
                msg = Some(format!("Charging started ({}%)", current_level));
            }
            // Battery full (100%)
            else if current_level == 100 && last_level < 100 && battery_charging {
                msg = Some("Battery full".to_string());
            }

            if let Some(body) = msg
                && let Err(err) = self.show_notification(product_name, &body)
            {
                log::error!("Failed to show notification: {:?}", err);
            }
        }

        self.last_notification_state = Some((current_level, current_status));
    }

    pub fn show_notification(&mut self, product_name: &str, body: &str) -> Result<()> {
        let builder = NotificationBuilder::new()
            .visual(Text::create(0, product_name).with_style(HintStyle::Title))
            .visual(Text::create(1, &body).with_style(HintStyle::Body));

        builder
            .build(0, &self.toast_notifier, product_name, "battery")
            .context("building notification")?
            .show()
            .context("showing notification")
    }
}

#[cfg(windows)]
pub fn register_notifications_id() -> Result<String> {
    // Win32 Toast notifications typically require a Start Menu shortcut whose
    // AppUserModelID matches the notifier ID. Without this, `show()` can succeed
    // but nothing appears.

    let app_id = if cfg!(debug_assertions) {
        // In debug mode, use a common AUMID to avoid needing a Start Menu shortcut
        "Microsoft.Windows.Explorer"
    } else {
        // In release mode, AUMID can be anything because the executable is already registered to some AUMID generated by inno setup
        "HeadsetBatteryIndicator.App"
    };

    // Ensure the system associates this running EXE with the same AUMID.
    unsafe {
        use anyhow::Context;

        SetCurrentProcessExplicitAppUserModelID(&HSTRING::from(app_id))
            .context("SetCurrentProcessExplicitAppUserModelID")?;
    }

    Ok(app_id.to_string())
}
